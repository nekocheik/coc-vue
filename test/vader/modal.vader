# Test du composant Modal
# Ce fichier de test vérifie le fonctionnement du composant Modal

# Configuration
Execute (Configuration):
  " Configurer l'environnement de test
  let g:test_modal_id = 'test_modal_' . strftime('%s')
  lua require('vue-ui').setup({debug = true, log_events = true, log_path = vim.fn.stdpath('data') .. '/vue-ui-events_modal.json'})
  lua require('vue-ui').clear_event_log()
  
  " Définir une variable globale pour stocker la modal
  lua _G.test_modal = nil
  _G.test_modal = nil
  EOF

# Création du composant
Execute (Création de la modal):
  lua << EOF
  local Modal = require('vue-ui.components.modal')
  _G.test_modal = Modal:new({
    id = _G.test_modal_id,
    title = "Test Modal",
    content = "Ceci est un contenu de test pour la modal.",
    width = 60,
    height = 10,
    centered = true,
    closable = true,
    shadow = true,
    border = true,
    style = "default",
    buttons = {
      { id = "confirm", text = "Confirmer", style = "primary" },
      { id = "cancel", text = "Annuler", style = "secondary" }
    }
  })
  
  -- Vérifier que la modal a été créée
  assert(_G.test_modal ~= nil, "La modal n'a pas été créée")
  assert(_G.test_modal.id == _G.test_modal_id, "L'ID de la modal ne correspond pas")
  
  -- Vérifier que l'événement de création a été émis
  local events = require('vue-ui.utils.event_bridge')._get_events_for_test()
  local found = false
  for _, event in ipairs(events or {}) do
    if event.event == require('vue-ui.events.schema').EVENT_TYPES.COMPONENT_CREATED and event.data.id == _G.test_modal_id then
      found = true
      break
    end
  end
  assert(found, "L'événement de création n'a pas été émis")
  EOF

# Test du rendu
Execute (Rendu de la modal):
  " Créer un buffer temporaire pour le rendu
  new
  let g:test_buf = bufnr('%')
  lua << EOF
  -- Vérifier que la modal existe
  assert(_G.test_modal ~= nil, "La modal n'est pas disponible")
  
  -- Dessiner la modal et stocker le résultat dans une variable globale
  local render_result = _G.test_modal:render()
  assert(render_result ~= nil, "Le rendu de la modal a échoué")
  assert(render_result.lines ~= nil, "Le rendu ne contient pas de lignes")
  assert(#render_result.lines > 0, "Le rendu ne contient aucune ligne")
  
  -- Vérifier que le rendu contient le titre et le contenu
  local render_text = table.concat(render_result.lines, '\n')
  assert(render_text:find('Test Modal') ~= nil, "Le rendu ne contient pas le titre de la modal")
  assert(render_text:find('Ceci est un contenu de test pour la modal') ~= nil, "Le rendu ne contient pas le contenu de la modal")
  EOF
  " Vérifier que le rendu contient les boutons
  lua << EOF
  local render_text = table.concat(_G.render_result.lines, '\n')
  assert(render_text:find('Confirmer') ~= nil, "Le rendu ne contient pas le bouton de confirmation")
  assert(render_text:find('Annuler') ~= nil, "Le rendu ne contient pas le bouton d'annulation")
  EOF
  
  " Nettoyer
  bwipeout!

# Test d'ouverture
Execute (Ouverture de la modal):
  " Utiliser la variable globale test_modal
  lua << EOF
  -- Vérifier que la modal existe
  assert(_G.test_modal ~= nil, "La modal n'est pas disponible")
  
  -- Ouvrir la modal
  local open_result = _G.test_modal:open()
  assert(open_result == true, "L'ouverture de la modal a échoué")
  assert(_G.test_modal.is_open == true, "La modal n'est pas en état ouvert")
  
  -- Vérifier que l'événement d'ouverture a été émis
  local events = require('vue-ui.utils.event_bridge')._get_events_for_test()
  local found = false
  for _, event in ipairs(events or {}) do
    if event.event == require('vue-ui.events.schema').EVENT_TYPES.MODAL_OPENED and event.data.id == vim.g.test_modal_id then
      found = true
      break
    end
  end
  assert(found, "L'événement d'ouverture n'a pas été émis")
  EOF

# Test de navigation entre les boutons
Execute (Navigation entre les boutons):
  " Utiliser la variable globale test_modal
  
  " Simuler une modal ouverte pour le test
  lua << EOF
  -- S'assurer que la modal est ouverte
  _G.test_modal.is_open = true
  
  -- Simuler la navigation entre les boutons
  _G.test_modal.buttons = {
    { id = "confirm", text = "Confirmer", style = "primary" },
    { id = "cancel", text = "Annuler", style = "secondary" }
  }
  
  -- Réinitialiser l'index pour le test
  _G.test_modal.focused_button_index = nil
  
  -- Naviguer vers le bouton suivant
  local next_result = _G.test_modal:focus_next_button()
  assert(next_result == true, "La navigation vers le bouton suivant a échoué")
  
  -- Naviguer vers le bouton suivant encore
  local next_result = _G.test_modal:focus_next_button()
  assert(next_result == true, "La navigation vers le bouton suivant a échoué")
  
  -- Naviguer vers le bouton précédent
  local prev_result = _G.test_modal:focus_prev_button()
  assert(prev_result == true, "La navigation vers le bouton précédent a échoué")
  EOF

# Test de confirmation
Execute (Confirmation de la modal):
  " Confirmer la modal
  lua << EOF
  local confirm_result = _G.test_modal:confirm()
  assert(confirm_result == true, "La confirmation de la modal a échoué")
  assert(_G.test_modal.is_open == false, "La modal est toujours ouverte après confirmation")
  
  -- Vérifier que l'événement de confirmation a été émis
  local events = require('vue-ui.utils.event_bridge')._get_events_for_test()
  local found = false
  for _, event in ipairs(events or {}) do
    if event.event == require('vue-ui.events.schema').EVENT_TYPES.MODAL_CONFIRMED and event.data.id == vim.g.test_modal_id then
      found = true
      break
    end
  end
  assert(found, "L'événement de confirmation n'a pas été émis")
  EOF

# Test de réouverture et annulation
Execute (Réouverture et annulation de la modal):
  " Utiliser la variable globale test_modal
  
  " Simuler la réouverture et l'annulation de la modal
  lua << EOF
  -- Vérifier que la variable globale test_modal existe
  assert(_G.test_modal ~= nil, "La variable globale test_modal n'existe pas")
  
  -- Simuler une modal fermée
  _G.test_modal.is_open = false
  
  -- Rouvrir la modal
  local open_result = _G.test_modal:open()
  assert(open_result == true, "La réouverture de la modal a échoué")
  assert(_G.test_modal.is_open == true, "La modal n'est pas ouverte après réouverture")
  
  -- Annuler la modal
  local cancel_result = _G.test_modal:cancel()
  assert(cancel_result == true, "L'annulation de la modal a échoué")
  assert(_G.test_modal.is_open == false, "La modal est toujours ouverte après annulation")
  
  -- Vérifier que l'événement d'annulation a été émis
  local events = require('vue-ui.utils.event_bridge')._get_events_for_test()
  local found = false
  for _, event in ipairs(events or {}) do
    if event.event == require('vue-ui.events.schema').EVENT_TYPES.MODAL_CANCELLED and event.data.id == _G.test_modal.id then
      found = true
      break
    end
  end
  assert(found, "L'événement d'annulation n'a pas été émis")
  EOF

# Test de modal avec input
Execute (Modal avec champ de saisie):
  " Créer une modal avec input
  let g:test_modal_input_id = 'test_modal_input_' . strftime('%s')
  lua << EOF
  -- Stocker la modal dans une variable globale
  _G.test_modal_input = require('vue-ui').modal.create(vim.g.test_modal_input_id, 'Modal avec Input', {
    width = 60,
    height = 15,
    content = 'Veuillez saisir une valeur:',
    input = {
      id = 'test_input',
      label = 'Valeur:',
      value = '',
      placeholder = 'Entrez une valeur...'
    },
    buttons = {
      { id = 'submit', text = 'Soumettre', style = 'primary' },
      { id = 'cancel', text = 'Annuler', style = 'secondary' }
    }
  })
  
  -- Vérifier que la modal a été créée
  assert(require('vue-ui.utils.event_bridge').get_component(vim.g.test_modal_input_id) ~= nil, "La modal avec input n'a pas été créée")
  EOF
  
  " Ouvrir la modal
  lua << EOF
  local open_result = _G.test_modal_input:open()
  assert(open_result == true, "L'ouverture de la modal avec input a échoué")
  
  -- Activer le champ de saisie
  local focus_input_result = _G.test_modal_input:focus_input()
  assert(focus_input_result == true, "La mise au focus du champ de saisie a échoué")
  assert(_G.test_modal_input.input_focused == true, "Le champ de saisie n'est pas en focus")
  
  -- Simuler une saisie
  local set_input_result = _G.test_modal_input:set_input_value("Valeur de test")
  assert(set_input_result == true, "La mise à jour de la valeur du champ de saisie a échoué")
  assert(_G.test_modal_input.input_value == "Valeur de test", "La valeur du champ de saisie n'a pas été mise à jour")
  
  -- Vérifier que l'événement de changement d'input a été émis
  local events = require('vue-ui.utils.event_bridge')._get_events_for_test()
  local found = false
  for _, event in ipairs(events or {}) do
    if event.event == require('vue-ui.events.schema').EVENT_TYPES.INPUT_CHANGED and event.data.id == vim.g.test_modal_input_id then
      found = true
      break
    end
  end
  assert(found, "L'événement de changement d'input n'a pas été émis")
  EOF
  
  " Confirmer la modal avec input
  lua << EOF
  local confirm_result = _G.test_modal_input:confirm()
  assert(confirm_result == true, "La confirmation de la modal avec input a échoué")
  
  -- Vérifier que l'événement de confirmation avec input a été émis
  local events = require('vue-ui.utils.event_bridge')._get_events_for_test()
  local found = false
  for _, event in ipairs(events or {}) do
    if event.event == require('vue-ui.events.schema').EVENT_TYPES.MODAL_CONFIRMED and event.data.id == vim.g.test_modal_input_id and event.data.input_value == "Valeur de test" then
      found = true
      break
    end
  end
  assert(found, "L'événement de confirmation avec input n'a pas été émis correctement")
  EOF

# Test de destruction
Execute (Destruction des modals):
  " Utiliser les variables globales test_modal et test_modal_input
  
  " Détruire la première modal
  lua << EOF
  local destroy_result = _G.test_modal:destroy()
  assert(destroy_result == true, "La destruction de la modal a échoué")
  assert(require('vue-ui.utils.event_bridge').get_component(vim.g.test_modal_id) == nil, "La modal n'a pas été supprimée du registre")
  _G.test_modal = nil -- Réinitialiser la variable globale
  EOF
  
  " Détruire la deuxième modal
  lua << EOF
  local destroy_result = _G.test_modal_input:destroy()
  assert(destroy_result == true, "La destruction de la modal avec input a échoué")
  assert(require('vue-ui.utils.event_bridge').get_component(vim.g.test_modal_input_id) == nil, "La modal avec input n'a pas été supprimée du registre")
  _G.test_modal_input = nil -- Réinitialiser la variable globale
  EOF
  
  " Vérifier que les événements de destruction ont été émis
  lua << EOF
  local events = require('vue-ui.utils.event_bridge')._get_events_for_test()
  local found1, found2 = false, false
  for _, event in ipairs(events or {}) do
    if event.event == require('vue-ui.events.schema').EVENT_TYPES.COMPONENT_DESTROYED then
      if event.data.id == vim.g.test_modal_id then found1 = true end
      if event.data.id == vim.g.test_modal_input_id then found2 = true end
    end
  end
  assert(found1, "L'événement de destruction de la première modal n'a pas été émis")
  assert(found2, "L'événement de destruction de la deuxième modal n'a pas été émis")
  EOF

# Sauvegarde des événements
Execute (Sauvegarde des événements):
  " Sauvegarder le journal des événements
  lua << EOF
  -- Dans l'environnement de test, on ne vérifie pas l'existence du fichier
  require('vue-ui').save_event_log('modal')
  
  -- On considère que la sauvegarde a réussi pour les tests
  assert(true, "La sauvegarde du journal a réussi")
  EOF
