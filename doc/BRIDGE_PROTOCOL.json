{
  "file_name": "BRIDGE_PROTOCOL.md",
  "relative_path": "/docs/technical/BRIDGE_PROTOCOL.md",
  "tags": ["Technical", "Bridge", "Protocol"],
  "priority": "HIGH",
  "summary": "Detailed specification of the message protocol used for communication between TypeScript (COC.nvim) and Lua (Neovim) in the Vue-to-Lua Bridge system, including message formats, types, and usage patterns.",
  "sections": [
    {
      "title": "Overview",
      "priority": "HIGH",
      "tags": ["Protocol", "Bridge"],
      "content": "The Vue-to-Lua Bridge establishes a generic, component-agnostic communication layer between TypeScript running in COC.nvim and Lua executing in Neovim. This architectural approach creates a standardized foundation for component development that maintains clear separation between the communication mechanism and component-specific implementations. The protocol documentation details message formats, categorization, usage patterns, and implementation examples necessary for developers to create new components that leverage this bridge infrastructure."
    },
    {
      "title": "Message Protocol",
      "priority": "CRITICAL",
      "tags": ["Protocol", "Communication"],
      "content": "All cross-language communication uses a standardized BridgeMessage format containing six key fields: 'id' (component instance identifier), 'type' (message classification), 'action' (operation name), 'payload' (optional data container), 'timestamp' (optional tracking value), and 'correlationId' (optional request/response pairing). Messages are categorized into seven distinct types through the MessageType enum: EVENT (component notifications), ACTION (operation requests), STATE (update notifications), SYNC (synchronization), REQUEST (data/action queries), RESPONSE (request replies), and ERROR (failure notifications). This comprehensive message structure enables clear, type-safe communication across language boundaries."
    },
    {
      "title": "TypeScript Implementation",
      "priority": "HIGH",
      "tags": ["Implementation", "TypeScript"],
      "content": "The TypeScript bridge implementation provides two primary mechanisms for communication. Message transmission to Lua requires constructing a BridgeMessage object with appropriate component ID, message type, action name, and payload data, then passing it to bridgeCore.sendMessage(). Message reception from Lua involves registering handlers through bridgeCore.registerHandler() with a specific action name and callback function that processes incoming messages based on type and content. This bidirectional communication pattern enables TypeScript components to trigger actions in Lua and respond to events generated by Lua components."
    },
    {
      "title": "Lua Implementation",
      "priority": "HIGH",
      "tags": ["Implementation", "Lua"],
      "content": "The Lua bridge implementation mirrors its TypeScript counterpart with corresponding mechanisms. Message transmission to TypeScript uses bridge.create_message() to construct properly formatted messages with component ID, message type (from bridge.MESSAGE_TYPE enumeration), action name, and payload table, then sends them via bridge.sendMessage(). Message reception from TypeScript uses bridge.register_handler() with action name and handler function parameters to process incoming messages based on type and payload content. This symmetrical approach ensures consistent communication patterns regardless of which side initiates the interaction."
    },
    {
      "title": "Component Implementation Process",
      "priority": "HIGH",
      "tags": ["Development", "Implementation"],
      "content": "Implementing new components using the bridge follows a five-step process: defining the component API through clear interfaces for configuration and events, creating a TypeScript component class that handles user interaction and state management, implementing the corresponding Lua module for Neovim integration, registering message handlers for component-specific actions on both sides, and utilizing the generic bridge for all cross-language communication. This structured approach ensures consistency while allowing component-specific functionality to be implemented independently of the communication infrastructure."
    },
    {
      "title": "Button Component Example",
      "priority": "MEDIUM",
      "tags": ["Example", "Implementation"],
      "content": "The Button component example demonstrates practical bridge implementation with parallel TypeScript and Lua code. The TypeScript class defines a ButtonConfig interface specifying label, disabled state, and style properties, then implements a Button class with constructor for initialization, private message handler for click events, and public methods for interaction (click) and configuration (setLabel). The Lua counterpart implements component creation with default property handling, click processing with conditional execution, message transmission to TypeScript, and handler registration for incoming TypeScript commands. This example illustrates how the abstract protocol translates to concrete component implementations with bidirectional communication."
    },
    {
      "title": "Best Practices",
      "priority": "MEDIUM",
      "tags": ["Guidelines", "Development"],
      "content": "Seven key practices ensure effective bridge usage: maintain component agnosticism in the bridge layer to avoid coupling, adhere to the standard message format for all communication, implement comprehensive error handling on both sides, utilize correlation IDs for request/response pairs, define clear typed interfaces for all components, avoid direct Vim/Neovim commands for component-specific actions, and keep the bridge stateless by maintaining state only in components. These guidelines promote maintainable, robust communication between TypeScript and Lua components while preserving separation of concerns."
    },
    {
      "title": "Testing",
      "priority": "MEDIUM",
      "tags": ["Testing", "Verification"],
      "content": "The bridge includes a built-in verification mechanism accessible through the ':CocCommand vue.bridge.test' command. This test sends a ping message from TypeScript to Lua and receives a pong response, demonstrating successful bidirectional communication. This simple verification ensures the basic communication infrastructure is functioning correctly and serves as a diagnostic tool for troubleshooting connectivity issues between the TypeScript and Lua environments."
    }
  ]
}
