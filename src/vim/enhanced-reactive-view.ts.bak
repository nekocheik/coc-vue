/**
 * Implémentation améliorée d'une vue réactive pour Vim
 * 
 * Cette classe utilise:
 * - Un système de réactivité inspiré de Vue.js
 * - Un shadow buffer pour éviter les clignotements lors des mises à jour
 * - Une file d'attente de rendu pour optimiser les performances
 */
import { workspace } from 'coc.nvim';
import { VimBufferManager } from './buffer-manager';
import { ReactiveStateManager } from './reactive-state-manager';
import { RenderQueueManager } from './render-queue-manager';
import { ShadowBufferManager } from './shadow-buffer-manager';

// Interface pour un composant réactif
export interface ReactiveComponent {
  // Position et taille
  lineStart: number;
  lineCount: number;
  
  // Méthode pour rendre le composant
  render(): string[];
  
  // Méthode pour gérer une interaction utilisateur
  handleKeypress?(key: string): Promise<boolean>;
  
  // Méthodes du cycle de vie
  mounted?(): Promise<void>;
  beforeUnmount?(): Promise<void>;
}

/**
 * Classe principale pour la vue réactive améliorée
 * Cette version utilise une architecture modulaire avec des gestionnaires spécialisés
 */
export class EnhancedReactiveView {
  private bufferManager: VimBufferManager | null = null;
  private components: Map<string, ReactiveComponent> = new Map();
  private activeComponentId: string | null = null;
  private bufnr: number = -1;
  private isDestroyed: boolean = false;
  private keymapHandlers: Map<string, (key: string) => Promise<void>> = new Map();
  private needsBufferRestore: boolean = false;
  private updateInterval: number = 1000; // Intervalle de mise à jour en ms
  private updateTimer: NodeJS.Timeout | null = null;
  private forceRefreshTimer: NodeJS.Timeout | null = null;
  private forceRefreshInterval: number = 5000; // 5 secondes par défaut
  
  // Gestionnaires spécialisés pour une meilleure séparation des responsabilités
  private stateManager: ReactiveStateManager;
  private renderQueueManager: RenderQueueManager;
  private shadowBufferManager: ShadowBufferManager | null = null;
  
  /**
   * Constructeur
   * @param title Titre du buffer
   */
  constructor(title: string = 'Vue.js Demo') {
    this.title = title;
    
    // Initialiser les gestionnaires
    this.stateManager = new ReactiveStateManager();
    
    // La file d'attente de rendu appelle renderComponents quand des composants doivent être rendus
    this.renderQueueManager = new RenderQueueManager(
      async (componentIds) => {
        await this.renderComponents(componentIds);
      },
      30 // debounce de 30ms entre les rendus
    );
  }
  
  private title: string;
  
  /**
   * Obtenir le numéro du buffer
   */
  public getBufferNumber(): number {
    return this.bufnr;
  }
  
  /**
   * Définir l'intervalle de mise à jour (en ms)
   */
  public setUpdateInterval(interval: number): void {
    this.updateInterval = interval;
    
    // Redémarrer le timer avec le nouvel intervalle si déjà actif
    if (this.updateTimer) {
      this.stopAutoUpdate();
      this.startAutoUpdate();
    }
  }
  
  /**
   * Démarrer le système réactif de mise à jour
   */
  private startAutoUpdate(): void {
    // Arrêter les timers existants pour éviter les doublons
    this.stopAutoUpdate();
    
    console.log(`[ENHANCED-VIEW] Démarrage du système réactif pour buffer #${this.bufnr}`);
    
    // IMPORTANT: Utilisation du système réactif plutôt que d'un timer
    // Définir un callback global qui sera appelé quand n'importe quelle valeur réactive change
    this.stateManager.setGlobalUpdateCallback(async () => {
      try {
        // Vérifier si le buffer est valide
        if (this.isDestroyed || !(await this.isBufferSafeForRender())) {
          console.log(`[ENHANCED-VIEW] Buffer #${this.bufnr} invalide lors d'une notification réactive, arrêt du système`); 
          this.stopAutoUpdate();
          return;
        }

        // Vérifier que ce buffer existe toujours avant d'appliquer des changements
        const nvim = workspace.nvim;
        const bufExists = await nvim.eval(`bufexists(${this.bufnr})`) as number;
        
        if (!bufExists) {
          console.log(`[ENHANCED-VIEW] Le buffer #${this.bufnr} n'existe plus, arrêt du système réactif`);
          this.stopAutoUpdate();
          return;
        }

        console.log(`[ENHANCED-VIEW] Notification de changement réactif pour buffer #${this.bufnr}`);
        
        // Les composants individuels seront déjà mis à jour via leur propre système réactif
        // Ce callback global s'assure que les changements sont appliqués au buffer
        // même quand il n'est pas actif
        
        // Déterminer si nous sommes dans le buffer actif
        const currentBufnr = await nvim.eval('bufnr("%")') as number;
        const isCurrentBuffer = currentBufnr === this.bufnr;
        
        // Si le buffer n'est pas actif mais qu'il y a eu des changements, les appliquer
        if (!isCurrentBuffer && this.shadowBufferManager && this.shadowBufferManager.isDirtyBuffer()) {
          console.log(`[ENHANCED-VIEW] Application des changements réactifs au buffer inactif #${this.bufnr}`);
          await this.shadowBufferManager.applyChanges();
        }
      } catch (error) {
        console.error(`[ENHANCED-VIEW] Erreur dans le système réactif:`, error);
      }
    });
    
    // Garder une petite vérification de sécurité en cas de problème avec le système réactif
    // mais avec un intervalle beaucoup plus long puisque le système réactif devrait gérer la plupart des cas
    this.updateTimer = setInterval(async () => {
      try {
        if (this.isDestroyed || !(await this.isValidBufferForUpdate())) {
          return;
        }
        
        // Forcer une synchronisation complète occasionnellement
        console.log(`[ENHANCED-VIEW] Vérification périodique de sécurité pour buffer #${this.bufnr}`);
        await this.forceRefreshAllComponents();
      } catch (error) {
        console.error(`[ENHANCED-VIEW] Erreur dans la vérification de sécurité:`, error);
      }
    }, 10000); // Intervalle plus long (10 secondes)
  }

  /**
   * Exécute un cycle de mise à jour automatique
   */
  private async performAutoUpdate(): Promise<void> {
    try {
      if (this.isDestroyed) {
        this.stopAutoUpdate();
        return;
      }
      
      // Vérifier si le buffer existe toujours
      const bufExists = await this.isValidBufferForUpdate();
      if (!bufExists) {
        console.log(`[ENHANCED-VIEW] Buffer #${this.bufnr} n'existe plus, arrêt des mises à jour`);
        this.stopAutoUpdate();
        return;
      }
      
      // Vérifier si le buffer est le buffer actif
      const nvim = workspace.nvim;
      const currentBufnr = await nvim.eval('bufnr("%")') as number;
      const isCurrentBuffer = currentBufnr === this.bufnr;
      
      console.log(`[ENHANCED-VIEW] Cycle de mise à jour automatique pour buffer #${this.bufnr} (est buffer actif: ${isCurrentBuffer})`);
      
      // Déclencher une mise à jour de tous les composants
      await this.updateVisibleComponents();
      
      // Attendre un peu pour laisser le temps au système réactif de mettre le shadow buffer à jour
      await new Promise(resolve => setTimeout(resolve, 50));
      
      // Appliquer les changements du shadow buffer si nécessaire (buffer non actif)
      if (!isCurrentBuffer && this.shadowBufferManager) {
        // Vérifier explicitement si le buffer est sale, même s'il ne l'est pas encore
        const isDirty = this.shadowBufferManager.isDirtyBuffer();
        console.log(`[ENHANCED-VIEW] Buffer ${this.bufnr} est-il dirty? ${isDirty}`);
        
        if (isDirty) {
          console.log(`[ENHANCED-VIEW] Application des changements du shadow buffer pour #${this.bufnr}`);
          await this.shadowBufferManager.applyChanges();
        } else {
          // Même si le shadow buffer n'est pas marqué comme sale, forcer une mise à jour
          // pour s'assurer que les composants sont à jour
          console.log(`[ENHANCED-VIEW] Initialisation et application forcée du shadow buffer pour #${this.bufnr}`);
          await this.shadowBufferManager.initialize();
          
          // Rendre à nouveau tous les composants dans le shadow buffer
          for (const [id, component] of this.components.entries()) {
            const renderedLines = component.render();
            this.shadowBufferManager.updateLines(component.lineStart, renderedLines);
          }
          
          // Appliquer les changements
          await this.shadowBufferManager.applyChanges();
        }
      }
    } catch (error) {
      console.error(`[ENHANCED-VIEW] Erreur dans la mise à jour automatique:`, error);
    }
  }
  
  /**
   * Arrêter les mises à jour automatiques
   */
  private stopAutoUpdate(): void {
    if (this.updateTimer) {
      clearInterval(this.updateTimer);
      this.updateTimer = null;
      console.log(`[ENHANCED-VIEW] Arrêt des mises à jour automatiques pour buffer #${this.bufnr}`);
    }
    
    // Arrêter aussi le rafraîchissement forcé
    if (this.forceRefreshTimer) {
      clearInterval(this.forceRefreshTimer);
      this.forceRefreshTimer = null;
      console.log(`[ENHANCED-VIEW] Arrêt du rafraîchissement forcé pour buffer #${this.bufnr}`);
    }
  }
  
  /**
   * Définir une valeur réactive dans le store global
   */
  public setState(key: string, value: any): void {
    this.stateManager.setState(key, value);
  }
  
  /**
   * Obtenir une valeur du store réactif
   */
  public getState<T>(key: string, defaultValue?: T): T {
    return this.stateManager.getState(key, defaultValue);
  }
  
  /**
   * Démarre le timer de rafraîchissement forcé qui recharge et applique tous les composants réactifs
   * Méthode critique pour assurer que les buffers non actifs sont à jour
   */
  private startForceRefreshTimer(): void {
    if (this.forceRefreshTimer) {
      clearInterval(this.forceRefreshTimer);
    }
    
    console.log(`[ENHANCED-VIEW] Démarrage du rafraîchissement forcé pour buffer #${this.bufnr} à intervalle de ${this.forceRefreshInterval}ms`);
    
    // Déclencher un premier rafraîchissement immédiatement
    this.forceRefreshAllComponents();
    
    // Mettre en place le timer régulier pour les rafraîchissements suivants
    this.forceRefreshTimer = setInterval(() => this.forceRefreshAllComponents(), this.forceRefreshInterval);
  }
  
  /**
   * Force le rafraîchissement de l'affichage du buffer
   * Cette méthode est cruciale pour s'assurer que les changements sont visibles même sans interaction utilisateur
   */
  private async forceVimRefresh(): Promise<void> {
    try {
      if (this.isDestroyed) return;
      
      // Vérifier que le buffer est toujours valide
      if (!await this.isValidBufferForUpdate()) return;
      
      const nvim = workspace.nvim;
      const currentBufnr = await nvim.eval('bufnr("%")') as number;
      
      console.log(`[ENHANCED-VIEW] FORÇAGE PUISSANT du rafraîchissement visuel du buffer #${this.bufnr} (buffer actuel: #${currentBufnr})`);
      
      // Méthode 1: Manipuler l'état du buffer pour forcer le rafraîchissement
      await nvim.command(`silent! call setbufvar(${this.bufnr}, '&modified', 1)`);
      await nvim.command(`silent! call setbufvar(${this.bufnr}, '&modified', 0)`);
      
      // Méthode 2: Forcer un comportement qui rafraîchit l'affichage
      await nvim.command('doautocmd TextChanged');
      await nvim.command('doautocmd TextChangedI');
      
      // Méthode 3: Forcer redraw avec différentes options
      await nvim.command('redraw');
      await nvim.command('redraw!');
      
      // Méthode 4: Technique extrême - simuler un changement puis rafraîchir
      // Cette approche est plus agressive mais peut être nécessaire pour forcer la mise à jour visuelle
      if (currentBufnr !== this.bufnr) {
        // Si nous ne sommes pas dans le buffer actuel, essayer de forcer le rafraîchissement par un changement physique 
        // Sauvegarder le buffer courant
        await nvim.command('let save_view = winsaveview()');
        await nvim.command('let save_buf = bufnr("%")');
        
        try {
          // Basculer rapidement vers le buffer cible
          await nvim.command(`silent! buffer ${this.bufnr}`);
          
          // Modifier le buffer puis annuler pour forcer un rafraîchissement
          await nvim.command('setlocal modifiable');
          await nvim.command('normal! Go ');
          await nvim.command('normal! x');
          await nvim.command('setlocal nomodifiable');
          
          // Revenir au buffer précédent
          await nvim.command('silent! execute "buffer " . save_buf');
          await nvim.command('call winrestview(save_view)');
        } catch (e) {
          console.error(`[ENHANCED-VIEW] Erreur lors de la manipulation des buffers:`, e);
        }
      }
      
      // Méthode 5: Demander explicitement à Neovim de vérifier le contenu externe du fichier
      await nvim.command(`silent! checktime ${this.bufnr}`);
      
      console.log(`[ENHANCED-VIEW] Rafraîchissement visuel ULTRA FORCÉ pour buffer #${this.bufnr}`);
    } catch (error) {
      console.error(`[ENHANCED-VIEW] Erreur lors du forçage du rafraîchissement visuel:`, error);
    }
  }
  
  /**
   * Force le rafraîchissement complet de tous les composants et met à jour le buffer
   * Cette méthode est cruciale pour garantir que les mises à jour se produisent même pour les buffers non actifs
   * Contient des vérifications de sécurité strictées pour éviter les fuites de rendu
   */
  private async forceRefreshAllComponents(): Promise<void> {
    try {
      if (this.isDestroyed) return;
      
      // Vérifier que le buffer existe toujours
      if (!await this.isValidBufferForUpdate()) {
        console.log(`[ENHANCED-VIEW] Rafraîchissement annulé - buffer #${this.bufnr} invalide`);
        return;
      }
      
      // Vérifications de sécurité supplémentaires pour éviter les fuites
      const nvim = workspace.nvim;
      
      // 1. Vérifier que c'est un buffer Vue.js
      const bufferName = await nvim.eval(`bufname(${this.bufnr})`) as string;
      const bufferType = await nvim.eval(`getbufvar(${this.bufnr}, "&buftype")`) as string;
      const isVueBuffer = bufferName.includes('Vue.js') || bufferType === 'nofile';
      
      if (!isVueBuffer) {
        console.error(`[ENHANCED-VIEW] Sécurité: Le buffer #${this.bufnr} (${bufferName}, type=${bufferType}) ne semble pas être un buffer Vue.js, mise à jour annulée`);
        return;
      }
      
      // 2. Vérifier si le buffer a une variable spécifique que nous lui avons attribuée
      const hasVueMarker = await nvim.eval(`exists("b:is_vue_reactive_buffer")`) as number;
      const vueMarkerId = await nvim.eval(`get(b:, 'vue_buffer_id', 0)`) as number;
      
      if ((!hasVueMarker || vueMarkerId !== this.bufnr) && !isVueBuffer) {
        console.error(`[ENHANCED-VIEW] Sécurité: Le buffer #${this.bufnr} n'a pas les marqueurs Vue.js attendus. Mise à jour annulée pour éviter les fuites.`);
        return;
      }
      
      console.log(`[ENHANCED-VIEW] FORCE-REFRESH pour buffer #${this.bufnr} avec ${this.components.size} composant(s)`);
      
      // Déterminer si nous sommes dans le buffer actif
      const currentBuf = await nvim.eval('bufnr("%")') as number;
      const isCurrentBuffer = currentBuf === this.bufnr;
      
      console.log(`[ENHANCED-VIEW] Buffer actuel: #${currentBuf}, notre buffer: #${this.bufnr}, actif: ${isCurrentBuffer}`);
      
      // Si nous avons un shadow buffer, initialiser avant de commencer les mises à jour
      if (!isCurrentBuffer && this.shadowBufferManager) {
        console.log(`[ENHANCED-VIEW] Initialisation du shadow buffer pour buffer inactif #${this.bufnr}`);
        await this.shadowBufferManager.initialize();
      }
      
      // Appliquer le rendu forcé de tous les composants un par un
      for (const [componentId, component] of this.components.entries()) {
        console.log(`[ENHANCED-VIEW] FORCE-REFRESH du composant ${componentId}`);
        
        try {
          // Recalculer explicitement le contenu du composant
          const renderedLines = component.render();
          
          // Si dans le buffer actif, mettre à jour directement
          if (isCurrentBuffer) {
            await this.updateBufferLines(component.lineStart, renderedLines);
          } 
          // Sinon utiliser le shadow buffer
          else if (this.shadowBufferManager) {
            this.shadowBufferManager.updateLines(component.lineStart, renderedLines);
          }
        } catch (compError) {
          console.error(`[ENHANCED-VIEW] Erreur lors du rendu forcé du composant ${componentId}:`, compError);
        }
      }
      
      // Appliquer les changements du shadow buffer si nécessaire
      if (!isCurrentBuffer && this.shadowBufferManager) {
        console.log(`[ENHANCED-VIEW] Application des changements du shadow buffer pour #${this.bufnr}`);
        await this.shadowBufferManager.applyChanges();
      }
      
      // CRITIQUE: Forcer le rafraîchissement visuel de Vim même si le buffer n'est pas actif
      // Cela garantit que les changements sont visibles sans nécessiter d'interaction utilisateur
      await this.forceVimRefresh();
    } catch (error) {
      console.error(`[ENHANCED-VIEW] Erreur dans le rafraîchissement forcé:`, error);
    }
  }

  /**
   * Lier un composant à des clés du store pour le rendu automatique
   */
  public bindComponentToState(componentId: string, stateKeys: string[]): void {
    if (!this.components.has(componentId)) {
      console.error(`[ENHANCED-VIEW] Impossible de lier le composant ${componentId} - non trouvé`);
      return;
    }
    
    // Lier le composant au state manager
    this.stateManager.bindComponent(componentId, stateKeys, () => {
      // Quand l'état change, planifier le rendu de ce composant
      this.renderQueueManager.scheduleRender(componentId);
    });
    
    console.log(`[ENHANCED-VIEW] Composant ${componentId} lié à ${stateKeys.length} clés d'état`);
  }
  
  /**
   * Phase d'initialisation des composants (avant montage dans un buffer)
   */
  private async initializeComponents(): Promise<void> {
    // Étape 1: Notification que nous sommes dans la phase d'initialisation
    console.log(`[ENHANCED-VIEW] Initialisation des composants avant montage...`);
    
    // Étape 2: Appeler mounted() sur chaque composant pour leur permettre de s'initialiser
    for (const [id, component] of this.components.entries()) {
      try {
        await component.mounted();
        console.log(`[ENHANCED-VIEW] Composant ${id} initialisé`);
      } catch (error) {
        console.error(`[ENHANCED-VIEW] Erreur lors de l'initialisation du composant ${id}:`, error);
      }
    }
    
    console.log(`[ENHANCED-VIEW] Initialisation des composants terminée`);
  }

  /**
   * Démarre le timer de rafraîchissement forcé qui recharge et applique tous les composants réactifs
   * Méthode critique pour assurer que les buffers non actifs sont à jour
   */
  private startForceRefreshTimer(): void {
    if (this.forceRefreshTimer) {
      clearInterval(this.forceRefreshTimer);
    }
    
    console.log(`[ENHANCED-VIEW] Démarrage du rafraîchissement forcé pour buffer #${this.bufnr} à intervalle de ${this.forceRefreshInterval}ms`);
    
    // Déclencher un premier rafraîchissement immédiatement
    this.forceRefreshAllComponents();
    
    // Mettre en place le timer régulier pour les rafraîchissements suivants
    this.forceRefreshTimer = setInterval(() => this.forceRefreshAllComponents(), this.forceRefreshInterval);
  }

/**
 * Force le rafraîchissement de l'affichage du buffer
 * Cette méthode est cruciale pour s'assurer que les changements sont visibles même sans interaction utilisateur
 */
private async forceVimRefresh(): Promise<void> {
  try {
    if (this.isDestroyed) return;

    // Vérifier que le buffer est toujours valide
    if (!await this.isValidBufferForUpdate()) return;

    const nvim = workspace.nvim;
    const currentBufnr = await nvim.eval('bufnr("%")') as number;

    console.log(`[ENHANCED-VIEW] FORÇAGE PUISSANT du rafraîchissement visuel du buffer #${this.bufnr} (buffer actuel: #${currentBufnr})`);

    // Méthode 1: Manipuler l'état du buffer pour forcer le rafraîchissement
    await nvim.command(`silent! call setbufvar(${this.bufnr}, '&modified', 1)`);
    await nvim.command(`silent! call setbufvar(${this.bufnr}, '&modified', 0)`);

    // Méthode 2: Forcer un comportement qui rafraîchit l'affichage
    await nvim.command('doautocmd TextChanged');
    await nvim.command('doautocmd TextChangedI');

    // Méthode 3: Forcer redraw avec différentes options
    await nvim.command('redraw');
    await nvim.command('redraw!');

    // Méthode 4: Technique extrême - simuler un changement puis rafraîchir
    // Cette approche est plus agressive mais peut être nécessaire pour forcer la mise à jour visuelle
    if (currentBufnr !== this.bufnr) {
      // Si nous ne sommes pas dans le buffer actuel, essayer de forcer le rafraîchissement par un changement physique 
      // Sauvegarder le buffer courant
      await nvim.command('let save_view = winsaveview()');
      await nvim.command('let save_buf = bufnr("%")');

      try {
        // Basculer rapidement vers le buffer cible
        await nvim.command(`silent! buffer ${this.bufnr}`);

        // Modifier le buffer puis annuler pour forcer un rafraîchissement
        await nvim.command('setlocal modifiable');
        await nvim.command('normal! Go ');
        await nvim.command('normal! x');
        await nvim.command('setlocal nomodifiable');

        // Revenir au buffer précédent
        await nvim.command('silent! execute "buffer " . save_buf');
        await nvim.command('call winrestview(save_view)');
      } catch (e) {
        console.error(`[ENHANCED-VIEW] Erreur lors de la manipulation des buffers:`, e);
      }
    }

    // Méthode 5: Demander explicitement à Neovim de vérifier le contenu externe du fichier
    await nvim.command(`silent! checktime ${this.bufnr}`);

    console.log(`[ENHANCED-VIEW] Rafraîchissement visuel ULTRA FORCÉ pour buffer #${this.bufnr}`);
  } catch (error) {
    console.error(`[ENHANCED-VIEW] Erreur lors du forçage du rafraîchissement visuel:`, error);
  }
}

/**
 * Force le rafraîchissement complet de tous les composants et met à jour le buffer
 * Cette méthode est cruciale pour garantir que les mises à jour se produisent même pour les buffers non actifs
 * Contient des vérifications de sécurité strictées pour éviter les fuites de rendu
 */
private async forceRefreshAllComponents(): Promise<void> {
  try {
    if (this.isDestroyed) return;

    // Vérifier que le buffer existe toujours
    if (!await this.isValidBufferForUpdate()) {
      console.log(`[ENHANCED-VIEW] Rafraîchissement annulé - buffer #${this.bufnr} invalide`);
      return;
    }

    // Vérifications de sécurité supplémentaires pour éviter les fuites
    const nvim = workspace.nvim;

    // 1. Vérifier que c'est un buffer Vue.js
    const bufferName = await nvim.eval(`bufname(${this.bufnr})`) as string;
    const bufferType = await nvim.eval(`getbufvar(${this.bufnr}, "&buftype")`) as string;
    const isVueBuffer = bufferName.includes('Vue.js') || bufferType === 'nofile';

    if (!isVueBuffer) {
      console.error(`[ENHANCED-VIEW] Sécurité: Le buffer #${this.bufnr} (${bufferName}, type=${bufferType}) ne semble pas être un buffer Vue.js, mise à jour annulée`);
      return;
    }

    // 2. Vérifier si le buffer a une variable spécifique que nous lui avons attribuée
    const hasVueMarker = await nvim.eval(`exists("b:is_vue_reactive_buffer")`) as number;
    const vueMarkerId = await nvim.eval(`get(b:, 'vue_buffer_id', 0)`) as number;

    if ((!hasVueMarker || vueMarkerId !== this.bufnr) && !isVueBuffer) {
      console.error(`[ENHANCED-VIEW] Sécurité: Le buffer #${this.bufnr} n'a pas les marqueurs Vue.js attendus. Mise à jour annulée pour éviter les fuites.`);
      return;
    }

    console.log(`[ENHANCED-VIEW] FORCE-REFRESH pour buffer #${this.bufnr} avec ${this.components.size} composant(s)`);

    // Déterminer si nous sommes dans le buffer actif
    const currentBuf = await nvim.eval('bufnr("%")') as number;
    const isCurrentBuffer = currentBuf === this.bufnr;

    console.log(`[ENHANCED-VIEW] Buffer actuel: #${currentBuf}, notre buffer: #${this.bufnr}, actif: ${isCurrentBuffer}`);

    // Si nous avons un shadow buffer, initialiser avant de commencer les mises à jour
    if (!isCurrentBuffer && this.shadowBufferManager) {
      console.log(`[ENHANCED-VIEW] Initialisation du shadow buffer pour buffer inactif #${this.bufnr}`);
      await this.shadowBufferManager.initialize();
      
      console.log(`[ENHANCED-VIEW] Vue montée dans le buffer #${this.bufnr}`);
    } catch (error) {
      console.error('[ENHANCED-VIEW] Erreur lors du montage de la vue:', error);
    }
  }
  
  /**
   * Configurer les mappages clavier de base
   */
  private async setupKeyMappings(): Promise<void> {
    if (!this.bufferManager) return;
    
    try {
      const nvim = workspace.nvim;
      
      // Créer un mapping pour chaque touche qui appelle notre fonction handleKeypress
      const keys = ['j', 'k', '<CR>', '<Tab>', '<Space>', 'q'];
      
      for (const key of keys) {
        // Utiliser des mappages non récursifs
        await nvim.command(
          `nnoremap <silent> <buffer> ${key} :call coc#rpc#notify('doKeymap', ['cocvue-${key}'])<CR>`
        );
        
        // Enregistrer les gestionnaires d'événements clavier
        workspace.registerKeymap(
          ['n'],
          `cocvue-${key}`,
          async () => {
            await this.handleKeypress(key);
          },
          { sync: false }
        );
      }
      
      console.log('[ENHANCED-VIEW] Mappages clavier configurés');
    } catch (error) {
      console.error('[ENHANCED-VIEW] Erreur lors de la configuration des mappages clavier:', error);
    }
  }
  
  /**
   * Gérer l'appui sur une touche
   */
  public async handleKeypress(key: string): Promise<void> {
    if (this.isDestroyed) return;
    
    console.log(`[ENHANCED-VIEW] Touche pressée: ${key}`);
    
    // Vérifier d'abord si c'est un gestionnaire personnalisé
    if (this.keymapHandlers.has(key)) {
      const handler = this.keymapHandlers.get(key);
      if (handler) {
        await handler(key);
        return;
      }
    }
    
    // Gestionnaires par défaut
    switch (key) {
      case 'j':
        await this.focusNextComponent();
        break;
      case 'k':
        await this.focusPreviousComponent();
        break;
      case 'q':
        await this.destroy();
        break;
      default:
        // Si un composant est actif, lui transmettre l'événement
        if (this.activeComponentId) {
          const component = this.components.get(this.activeComponentId);
          if (component && component.handleKeypress) {
            const handled = await component.handleKeypress(key);
            if (handled) return;
          }
        }
    }
  }
  
  /**
   * Ajouter un composant à la vue
   */
  public registerComponent(id: string, component: ReactiveComponent): void {
    this.components.set(id, component);
    console.log(`[ENHANCED-VIEW] Composant '${id}' enregistré`);
    
    // Appeler mounted si défini
    if (component.mounted) {
      component.mounted().catch(error => {
        console.error(`[ENHANCED-VIEW] Erreur lors du montage du composant ${id}:`, error);
      });
    }
    
    // Si c'est le premier composant, le définir comme actif
    if (this.components.size === 1) {
      this.activeComponentId = id;
    }
  }
  
  /**
   * Obtenir un composant par son ID
   */
  public getComponent(id: string): ReactiveComponent | undefined {
    return this.components.get(id);
  }
  
  /**
   * Définir le composant actif
   */
  public async setActiveComponent(id: string): Promise<void> {
    if (!this.components.has(id) || this.activeComponentId === id) return;
    
    this.activeComponentId = id;
    console.log(`[ENHANCED-VIEW] Composant actif: ${id}`);
    
    // Mettre à jour l'affichage si nécessaire
    await this.highlightActiveComponent();
  }
  
  /**
   * Mettre en évidence le composant actif
   */
  private async highlightActiveComponent(): Promise<void> {
    if (!this.bufferManager || !this.activeComponentId) return;
    
    const component = this.components.get(this.activeComponentId);
    if (!component) return;
    
    try {
      const nvim = workspace.nvim;
      
      // Se positionner sur la première ligne du composant
      await nvim.command(`call cursor(${component.lineStart}, 1)`);
      
      // Mettre à jour le statut
      await nvim.command(`echo "Composant actif: ${this.activeComponentId}"`);
    } catch (error) {
      console.error('[ENHANCED-VIEW] Erreur lors de la mise en évidence du composant actif:', error);
    }
  }
  
  /**
   * Passer au composant suivant
   */
  public async focusNextComponent(): Promise<void> {
    if (this.components.size === 0) return;
    
    const componentIds = Array.from(this.components.keys());
    
    // Trouver l'index du composant actif
    const currentIndex = this.activeComponentId ? componentIds.indexOf(this.activeComponentId) : -1;
    const nextIndex = (currentIndex + 1) % componentIds.length;
    
    await this.setActiveComponent(componentIds[nextIndex]);
  }
  
  /**
   * Passer au composant précédent
   */
  public async focusPreviousComponent(): Promise<void> {
    if (this.components.size === 0) return;
    
    const componentIds = Array.from(this.components.keys());
    
    // Trouver l'index du composant actif
    const currentIndex = this.activeComponentId ? componentIds.indexOf(this.activeComponentId) : 0;
    const prevIndex = (currentIndex - 1 + componentIds.length) % componentIds.length;
    
    await this.setActiveComponent(componentIds[prevIndex]);
  }
  
  /**
   * Mettre à jour tous les composants visibles
   * Cette méthode utilise le système de file d'attente pour batching
   */
  public async updateVisibleComponents(): Promise<void> {
    if (this.isDestroyed) return;
    
    try {
      console.log(`[ENHANCED-VIEW] Planification de la mise à jour de tous les composants`);
      
      // Ajouter tous les composants à la file d'attente de rendu
      const componentIds = Array.from(this.components.keys());
      this.renderQueueManager.scheduleMultipleRenders(componentIds);
    } catch (error) {
      console.error('[ENHANCED-VIEW] Erreur lors de la planification des mises à jour:', error);
    }
  }
  
  /**
   * Effectue le rendu des composants spécifiés
   * Cette méthode est appelée par le gestionnaire de file d'attente
   * et utilise le shadow buffer pour éviter les clignotements
   */
  private async renderComponents(componentIds: string[]): Promise<void> {
    if (componentIds.length === 0 || this.isDestroyed) return;
    
    console.log(`[ENHANCED-VIEW] Rendu de ${componentIds.length} composants...`);
    
    // Vérifier que le buffer est toujours valide
    if (!await this.isValidBufferForUpdate()) {
      console.log(`[ENHANCED-VIEW] Rendu annulé - buffer invalide`);
      return;
    }
    
    // Déterminer si nous sommes dans le buffer actif
    const nvim = workspace.nvim;
    const currentBuf = await nvim.eval('bufnr("%")') as number;
    const isCurrentBuffer = currentBuf === this.bufnr;
    
    // Préparer le shadow buffer si nous faisons une mise à jour en arrière-plan
    if (!isCurrentBuffer && this.shadowBufferManager) {
      await this.shadowBufferManager.initialize();
    }
    
    // Rendre chaque composant
    for (const componentId of componentIds) {
      const component = this.components.get(componentId);
      if (!component) continue;
      
      try {
        // Générer le contenu du composant
        const renderedLines = component.render();
        
        if (isCurrentBuffer) {
          // Mise à jour directe si nous sommes dans le buffer actif
          await this.updateBufferLines(component.lineStart, renderedLines);
        } else if (this.shadowBufferManager) {
          // Sinon, mettre à jour le shadow buffer
          this.shadowBufferManager.updateLines(component.lineStart, renderedLines);
        }
        
        console.log(`[ENHANCED-VIEW] Rendu du composant ${componentId} terminé`);
      } catch (error) {
        console.error(`[ENHANCED-VIEW] Erreur lors du rendu du composant ${componentId}:`, error);
      }
    }
    
    // Appliquer les changements si nous avons utilisé le shadow buffer
    if (!isCurrentBuffer && this.shadowBufferManager && this.shadowBufferManager.isDirtyBuffer()) {
      await this.shadowBufferManager.applyChanges();
    }
  }
  
  /**
   * Mettre à jour des lignes spécifiques dans le buffer
   */
  private async updateBufferLines(startLine: number, lines: string[]): Promise<void> {
    if (!this.bufferManager || this.isDestroyed) return;
    
    try {
      const nvim = workspace.nvim;
      const doc = await workspace.document;
      
      // Rendre le buffer modifiable temporairement
      await this.bufferManager.setModifiable(true);
      
      // Utiliser le document API de coc.nvim pour mettre à jour le buffer
      // Le startLine de Vim est 1-indexé, mais l'API attend 0-indexé
      const start = startLine - 1;
      const end = start + lines.length;
      
      // Déboguer les informations du buffer
      console.log(`[ENHANCED-VIEW] Mise à jour du buffer #${this.bufnr}, lignes ${start} à ${end-1}`);
      
      // Utiliser l'API document pour modifier le buffer
      await nvim.command(`call setline(${startLine}, ${JSON.stringify(lines)})`);
      
      // Alternative 1: si la méthode ci-dessus ne fonctionne pas
      // for (let i = 0; i < lines.length; i++) {
      //   await nvim.command(`call setline(${startLine + i}, ${JSON.stringify(lines[i])})`);
      // }
      
      // Alternative 2: si les méthodes ci-dessus ne fonctionnent pas
      // const buffer = await nvim.buffer;
      // await buffer.setLines(start, end, false, lines);
      
      // Remettre le buffer en mode non modifiable
      await this.bufferManager.setModifiable(false);
    } catch (error) {
      console.error(`[ENHANCED-VIEW] Erreur lors de la mise à jour des lignes:`, error);
    }
  }
  
  /**
   * Vérifie si le buffer est valide pour la mise à jour
   */
  private async isValidBufferForUpdate(): Promise<boolean> {
    try {
      if (!this.bufferManager) {
        console.log('[ENHANCED-VIEW] Gestionnaire de buffer non initialisé');
        return false;
      }
      
      // Vérifier si le buffer existe encore
      const exists = await this.bufferManager.exists();
      if (!exists) {
        console.log('[ENHANCED-VIEW] Buffer n\'existe plus, arrêt des mises à jour');
        this.destroy();
        return false;
      }
      
      // Vérifier si le buffer est chargé
      const nvim = workspace.nvim;
      const isLoaded = await nvim.eval(`bufloaded(${this.bufnr})`) as number;
      if (isLoaded !== 1) {
        console.log(`[ENHANCED-VIEW] Buffer #${this.bufnr} n'est pas chargé`);
        return false;
      }
      
      // Vérification du nom pour s'assurer qu'il s'agit du bon buffer
      const bufferName = await nvim.eval(`bufname(${this.bufnr})`) as string;
      
      // Normalisation des noms pour la comparaison
      const normalizedBufferName = bufferName.replace(/_/g, ' ');
      const normalizedTitle = this.title.replace(/ /g, ' ');
      
      // Vérifier par ID unique si disponible
      const bufferIdMatch = normalizedBufferName.match(/\(([^)]+)\)/);
      const titleIdMatch = normalizedTitle.match(/\(([^)]+)\)/);
      
      if (bufferIdMatch && titleIdMatch && bufferIdMatch[1] === titleIdMatch[1]) {
        return true;
      }
      
      // Vérifier par inclusion du titre
      if (normalizedBufferName.includes(normalizedTitle) || bufferName.includes(this.title)) {
        return true;
      }
      
      console.log(`[ENHANCED-VIEW] Nom de buffer invalide: ${bufferName}, attendu: ${this.title}`);
      return false;
    } catch (error) {
      console.error(`[ENHANCED-VIEW] Erreur lors de la vérification du buffer:`, error);
      return false;
    }
  }
  
  /**
   * Rendre tous les composants
   */
  public async renderAllComponents(): Promise<void> {
    if (!this.bufferManager || this.isDestroyed) return;
    
    try {
      // Vérifier que le buffer est valide
      if (!await this.isValidBufferForUpdate()) {
        return;
      }
      
      // Rendre le buffer modifiable
      await this.bufferManager.setModifiable(true);
      
      // Trier les composants par position
      const sortedComponents = Array.from(this.components.entries())
        .sort(([, a], [, b]) => a.lineStart - b.lineStart);
      
      // Effacer le contenu du buffer
      const nvim = workspace.nvim;
      await nvim.command('%delete');
      
      // Rendre chaque composant
      for (const [id, component] of sortedComponents) {
        const renderedLines = component.render();
        
        // Calculer le nombre de lignes nécessaires
        const requiredLines = component.lineStart + renderedLines.length - 1;
        const currentLines = await nvim.eval(`line('$')`) as number;
        
        // Ajouter des lignes vides si nécessaire
        if (requiredLines > currentLines) {
          const emptyLines = Array(requiredLines - currentLines).fill('');
          
          // Utiliser append pour ajouter des lignes vides à la fin du buffer
          // Utiliser '$' pour indiquer la dernière ligne (Vim indexe à partir de 1)
          const appendCmd = `call append('$', ${JSON.stringify(emptyLines)})`;
          console.log(`[ENHANCED-VIEW] Ajout de lignes vides: ${appendCmd}`);
          await nvim.command(appendCmd);
        }
        
        // Insérer le contenu rendu avec setline (fonctionne dans toutes les versions de Vim/Neovim)
        // Pour remplacer un bloc de lignes, nous devons appeler setline pour chaque ligne
        for (let i = 0; i < renderedLines.length; i++) {
          const lineNum = component.lineStart + i;
          const lineContent = JSON.stringify(renderedLines[i]);
          await nvim.command(`call setline(${lineNum}, ${lineContent})`);
        }
        
        console.log(`[ENHANCED-VIEW] Composant ${id} rendu`);
      }
      
      // Remettre le buffer en mode non modifiable
      await this.bufferManager.setModifiable(false);
      
      console.log('[ENHANCED-VIEW] Rendu complet terminé');
    } catch (error) {
      console.error('[ENHANCED-VIEW] Erreur lors du rendu complet:', error);
    }
  }
  
  /**
   * Ajouter un gestionnaire de touche personnalisé
   */
  public registerKeyHandler(key: string, handler: (key: string) => Promise<void>): void {
    this.keymapHandlers.set(key, handler);
    console.log(`[ENHANCED-VIEW] Gestionnaire de touche '${key}' enregistré`);
  }
  
  /**
   * Nettoyer et fermer la vue
   */
  public async destroy(): Promise<void> {
    if (this.isDestroyed) return;
    
    console.log('[ENHANCED-VIEW] Nettoyage des ressources...');
    
    // Marquer comme détruit pour éviter les appels ultérieurs
    this.isDestroyed = true;
    
    // Arrêter les mises à jour automatiques
    this.stopAutoUpdate();
    
    // Appeler beforeUnmount sur tous les composants
    for (const [id, component] of this.components.entries()) {
      if (component.beforeUnmount) {
        try {
          await component.beforeUnmount();
        } catch (error) {
          console.error(`[ENHANCED-VIEW] Erreur lors du démontage du composant ${id}:`, error);
        }
      }
    }
    
    // Supprimer tous les composants
    this.components.clear();
    
    // Nettoyer les gestionnaires d'état
    this.renderQueueManager.clear();
    
    // Fermer le buffer si nécessaire
    if (this.bufferManager && await this.bufferManager.exists()) {
      try {
        const nvim = workspace.nvim;
        await nvim.command(`bdelete! ${this.bufnr}`);
      } catch (error) {
        console.error('[ENHANCED-VIEW] Erreur lors de la fermeture du buffer:', error);
      }
    }
    
    console.log('[ENHANCED-VIEW] Vue détruite');
  }
}
